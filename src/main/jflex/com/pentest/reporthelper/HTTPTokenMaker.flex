/*
 * This file is based on the flex files from RSyntaxTextArea,
 * 
 * Also includes lots of code from restcli: https://github.com/restcli/restcli/blob/cc9087d883742b0c468b0b2874208f6827d210b5/src/main/java/uos/dev/restcli/parser/lexer.flex#L4
 *
 * WwwFormTokenMaker.java - Generates syntax tokens for HTTP requests and responses.
 * Specifically to "application/x-www-form-urlencoded" body.
 * Uses code from https://github.com/asm0dey/restcli
 */
package com.pentest.reporthelper.tokenmakers;

import java.io.*;
import javax.swing.text.Segment;

import org.fife.ui.rsyntaxtextarea.*;
import org.fife.ui.rsyntaxtextarea.modes.PlainTextTokenMaker;
import com.pentest.reporthelper.tokenmakers.util.ContentTypeManager;
// import org.fife.ui.rsyntaxtextarea.modes.*;

/**
 * A parser of HTTP requests {@code application/x-www-form-urlencoded}.
 *
 * @see <a href="http://www.w3.org/TR/html401/interact/forms.html#form-content-type">Form content type</a>
 */
%%

%public
%class HTTPTokenMaker
%extends MultipartAwareAbstractTokenMaker
%unicode
%type org.fife.ui.rsyntaxtextarea.Token
// %debug

%init{
	tokenMakerFactory = TokenMakerFactory.getDefaultInstance(); 
%init}


%{
	// MARK: -HTTPTokenMaker:Variables
	private static final boolean DEBUG = false;

	/** 
	 * Internal types denoting line endings 
	 */

	private static final int INTERNAL_HEADER						= -100;
	private static final int INTERNAL_BODY_URLENCODED_FORM			= -101;
	private static final int INTERNAL_BODY_FORM_DATA				= -102;
	private static final int INTERNAL_BODY_FORM_DATA_BODY			= -103;
	private static final int INTERNAL_ANY_BODY						= -104;
	private static final int INTERNAL_REQUEST_AND_RESPONSE			= -105;
	private static final int INTERNAL_PLAIN_TEXT					= -106;

	private final TokenMakerFactory tokenMakerFactory;

	private String currentFieldName = null;
	private Boolean isContentTypeHeader = false;
	private String contentType = "application/x-www-form-urlencoded";
	private Boolean isMultiplePart = false;
	private String multipartContentType = "text/plain";
	private Boolean isResponse = false;
	private Boolean isRequestCookieHeader = false;
	private Boolean isResponseCookieHeader = false;
	private ContentTypeManager contentTypeManager = new ContentTypeManager();
	private Integer responseOffset = 0;

	//MARK: -HTTPTokenMaker:Methods

	public HTTPTokenMaker() {
		super();
		tokenMakerFactory = TokenMakerFactory.getDefaultInstance();
	}

	public void resetContentTypeManager() {
		contentTypeManager = new ContentTypeManager();
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param tokenType The token's type.
	 */
	private void addToken(int tokenType) {
		T("addToken: %d (%s)", tokenType, yytext().toString().substring(0, Math.min(yytext().length(), 100)));
		addToken(zzStartRead, zzMarkedPos-1, tokenType);
	}

	

	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param tokenType The token's type.
	 */
	private void addToken(int start, int end, int tokenType) {
		int so = start + offsetShift;
		addToken(zzBuffer, start,end, tokenType, so);
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param array The character array.
	 * @param start The starting offset in the array.
	 * @param end The ending offset in the array.
	 * @param tokenType The token's type.
	 * @param startOffset The offset in the document at which this token
	 *                    occurs.
	 */
	@Override
	public void addToken(char[] array, int start, int end, int tokenType, int startOffset) {
		super.addToken(array, start,end, tokenType, startOffset);
		zzStartRead = zzMarkedPos;
	}


	@Override
	protected OccurrenceMarker createOccurrenceMarker() {
		return new HtmlOccurrenceMarker();
	}

	private int getStateForInitialTokenType(int initialTokenType, int startOffset) {
		int state = YYINITIAL;
		switch (initialTokenType) {
			case HTTPTokenMaker.INTERNAL_BODY_FORM_DATA:
			case HTTPTokenMaker.INTERNAL_BODY_FORM_DATA_BODY:
				contentType = "multipart/form-data";
				isMultiplePart = true;
				state = ANY_BODY;
				break;
			case HTTPTokenMaker.INTERNAL_ANY_BODY:
				contentType = "text/plain";
				isResponse = true;
				responseOffset = startOffset;
				state = ANY_BODY;
				break;
			case HTTPTokenMaker.INTERNAL_BODY_URLENCODED_FORM:
				contentType = "application/x-www-form-urlencoded";
				state = BODY_PARAM_NAME;
				break;
			case HTTPTokenMaker.INTERNAL_HEADER:
				state = REQ_LINE;
				break;
			case HTTPTokenMaker.INTERNAL_REQUEST_AND_RESPONSE:
				isResponse = true;
				responseOffset = startOffset;
				state = REQ_LINE;
				break;
			case HTTPTokenMaker.INTERNAL_PLAIN_TEXT:
				contentType = "text/plain";
				state = PLAIN_TEXT_BODY;
				break;
			default:
				state = YYINITIAL;
				break;
		}
		T("getStateForInitialTokenType: %d => %d", initialTokenType, state);
		return state;
	}

	private String getContentTypeForState() {
		// TODO: Make position & document aware ? Maybe not actually
		String shortContentType;
		if (contentType.toLowerCase().startsWith("multipart/")) {
			shortContentType = multipartContentType;
		} else {
			shortContentType = contentType;
		}
		T("getContentTypeForState: O: %s | N: %s", shortContentType, contentTypeManager.getContentType(zzStartRead));
		return shortContentType.split(";")[0];
	}

	//MARK: -HTTPTokenMaker::getTokenList

	/**
	 * Returns the first token in the linked list of tokens generated
	 * from <code>text</code>.  This method must be implemented by
	 * subclasses so they can correctly implement syntax highlighting.
	 *
	 * @param text The text from which to get tokens.
	 * @param initialTokenType The token type we should start with.
	 * @param startOffset The offset into the document at which
	 *        <code>text</code> starts.
	 * @return The first <code>Token</code> in a linked list representing
	 *         the syntax highlighted text.
	 */
	@Override
	public Token getTokenList(Segment text, int initialTokenType, int startOffset) {
		T("getTokenList entry (%d) %s", initialTokenType, text.toString().substring(0, Math.min(text.length(), 100)));
		resetTokenList();
		this.offsetShift = -text.offset + startOffset;
		int languageIndex = 0;
		try {
			if (initialTokenType == 0 || (initialTokenType <= INTERNAL_HEADER && initialTokenType >= INTERNAL_PLAIN_TEXT)) {
				T("getTokenList option 1");
				int state = getStateForInitialTokenType(initialTokenType, startOffset);
				setLanguageIndex(languageIndex);
				start = text.offset;
				s = text;
				yyreset(zzReader);
				yybegin(state);
				return yylex();
			} else {
				T("getTokenList option 2");
				TokenMaker tokenMaker = tokenMakerFactory.getTokenMaker(contentTypeManager.getContentType(zzStartRead));
				return tokenMaker.getTokenList(text, initialTokenType, startOffset);
			}
		} catch (java.lang.Error e) {
			T("getTokenList lang error");
			yyreset(zzReader);
			e.printStackTrace();
			return new TokenImpl();
		} catch (IOException ioe) {
			T("getTokenList exception caught");
			yyreset(zzReader);
			ioe.printStackTrace();
			return new TokenImpl();
		}
	}

	int errorPos = -1;

	private void handleInvalidToken() {
		if (errorPos != -1) {
			int currentZzStartRead = zzStartRead;
			addToken(errorPos, zzStartRead - 1, Token.IDENTIFIER);
			zzStartRead = currentZzStartRead;
			errorPos = -1;
		}
	}

	private void startInvalidToken() {
		if (errorPos == -1) {
			errorPos = zzMarkedPos - 1;
		}
	}

	private void addBodyEndToken() {
		switch (yystate()) {
			case ANY_BODY:
			T("addBodyEndToken: ANY_BODY");
				addEndToken(HTTPTokenMaker.INTERNAL_ANY_BODY);
				break;
			case BODY_PARAM_NAME:
			case BODY_PARAM_VALUE:
			T("addBodyEndToken: BODY_PARAM_NAME/BODY_PARAM_VALUE");
				addEndToken(HTTPTokenMaker.INTERNAL_REQUEST_AND_RESPONSE);
				break;
			case PLAIN_TEXT_BODY:
			T("addBodyEndToken: PLAIN_TEXT_BODY");
				addEndToken(HTTPTokenMaker.INTERNAL_PLAIN_TEXT);
				break;			
			default:
				T("addBodyEndToken called from unexpected state (%d)", yystate());
				addEndToken(HTTPTokenMaker.INTERNAL_BODY_FORM_DATA);
				break;
		}
	}
	
	private void addHeaderEndToken() {
		addEndToken(HTTPTokenMaker.INTERNAL_HEADER);
	}

	/**
	 * Adds the token specified to the current linked list of tokens as a header.
	 * Also commences Content-Type mode if found.
	 *
	 */
	private void addHeaderName() {
		String header = yytext();
		if (header.toLowerCase().startsWith("content-type")) {
			isContentTypeHeader = true;
		} else if (header.toLowerCase().endsWith("cookie")) {
			if (header.toLowerCase().startsWith("set-cookie")) {
				isResponseCookieHeader = true;
			} else if (header.toLowerCase().startsWith("cookie")) {
				isRequestCookieHeader = true;
			}
		}
		if (header.endsWith(":")) {
			addToken(zzStartRead, zzMarkedPos-2, Token.RESERVED_WORD);
			addToken(zzMarkedPos-1, zzMarkedPos-1, Token.RESERVED_WORD);
		} else {
			addToken(Token.RESERVED_WORD);
		}
	}


	private void addCookieTokens(String cookieHeader, Integer start) {
		String[]	cookies = cookieHeader.split(";");
		Integer		startOffset = start;
		
		for (String cookie : cookies) {
			String[]	cookieNameOrValue = cookie.split("=", 2);
			addToken(start, start+cookieNameOrValue[0].length() - 1, Token.MARKUP_TAG_ATTRIBUTE);
			start += cookieNameOrValue[0].length();
			addToken(start, start, Token.SEPARATOR); // Adding the '='
			start += 1;
			if (cookieNameOrValue.length > 1) {
				addToken(start, start+cookieNameOrValue[1].length() - 1, Token.MARKUP_TAG_ATTRIBUTE_VALUE);
				start += cookieNameOrValue[1].length();
				if (cookieHeader.substring(start - startOffset).startsWith(";")) {
					addToken(start, start, Token.SEPARATOR); // Adding the ';'
					start += 1;
				}
			}
			if (isResponseCookieHeader) {
				zzStartRead = start;
				addToken(Token.IDENTIFIER);
				break;
			}
		}
		isResponseCookieHeader = false;
		isRequestCookieHeader = false;
	}


	private void setContentType(String contentTypeHeaderValue) {
		isContentTypeHeader = false;
		// T("SetContentType: [%d] => %s",zzCurrentPos, contentTypeHeaderValue);
		if (isMultiplePart && !contentTypeHeaderValue.toLowerCase().contains("multipart/form-data;")) {
			multipartContentType = contentTypeHeaderValue.trim();
			contentTypeManager.setContentType(zzCurrentPos, contentTypeHeaderValue.trim());
		} else {
			contentTypeManager.setContentType(zzCurrentPos, contentTypeHeaderValue.trim());
			contentType = contentTypeHeaderValue.trim();
			if (contentType.toLowerCase().contains("multipart/form-data;")) {
				isMultiplePart = true;
				try {
					multiplePartBoundary = contentTypeHeaderValue.split("multipart/form-data;\\s*boundary=")[1];
					multiplePartBoundary = multiplePartBoundary.trim();
				} catch (ArrayIndexOutOfBoundsException e) {
					T("ERROR: Could not find boundary in multipart content-type field value");
					multiplePartBoundary = "-@-@-@-@-ERROR-@-@-@-@-";
				}
			}
		}
	}


	private void addHeaderValue() {
		String headerValue = yytext();
		Integer start = zzStartRead;
		Integer end = zzMarkedPos - 1;

		if (headerValue.startsWith(":")) {
			addToken(zzStartRead, zzStartRead, Token.VARIABLE);
			start += 1;
			headerValue = headerValue.substring(1);
		}
		while (headerValue.startsWith(" ")) {
			addToken(start, start, Token.WHITESPACE);
			start += 1;
			headerValue = headerValue.substring(1);
		}
		if (isRequestCookieHeader || isResponseCookieHeader) {		
			addCookieTokens(headerValue, start);
			return;
		}

		if (isContentTypeHeader) {
			setContentType(headerValue);
		}

		if (headerValue.endsWith("\n") || headerValue.endsWith("\r")) {
			addToken(start, zzMarkedPos-2, Token.VARIABLE);
			addToken(zzMarkedPos-1, zzMarkedPos-1, Token.WHITESPACE);
		} else {
			addToken(start, zzMarkedPos-1, Token.VARIABLE);
		}
	}


	private void setResponseMode() {
		contentType = "text/html";
		isResponse = true;
		responseOffset = zzCurrentPos;
	}


	private int getBodyStateForMode() {
		if (isResponse && zzCurrentPos > responseOffset) {
			return ANY_BODY;
		}
		return REQ_BODY;
	}

	private void fallbackToTokenMaker() {
		int chunkStart = zzStartRead;
		int chunkEnd   = zzMarkedPos;

		TokenMaker tokenMaker = tokenMakerFactory.getTokenMaker(contentTypeManager.getContentType(chunkStart));

		// RSTA's default PlaintTextTokenMaker does stuff we don't need and can't handle long files with no line breaks.
		// But it also cannot handle long tokens, so it's split up in the PLAIN_TEXT_BODY state.
		if (tokenMaker instanceof PlainTextTokenMaker) {
			yypushback(yylength());
			yybegin(PLAIN_TEXT_BODY);
			return;
		}

		// T("fallbackToTokenMaker: %s (%s) == %d", contentTypeManager.getContentType(zzCurrentPos), tokenMaker.getClass().getCanonicalName(), getBodyStateForMode());
		firstToken = (TokenImpl)tokenMaker.getTokenList(s, chunkStart, chunkEnd - 1);
		currentToken = (TokenImpl)firstToken.getLastPaintableToken();
		currentToken.setNextToken(null);
		zzMarkedPos = currentToken.getEndOffset();

		return;
		// T("fallbackToTokenMaker: %s (%d)", currentToken, zzMarkedPos);
	}


	private static final void T(String text, Object... arguments) {
  		if (DEBUG) {
    		System.out.printf("DEBUG:" + text + "\n", arguments);
		}
	}

%}

//MARK: -jflex:macros

Whitespace					= [ \t\f]+
InputCharacter = [^\r\n]
InputCharacterBoundary = [^\r\n-]
Digit = [0-9]

// Line terminators.
LineTerminator 				= [\r\n]+
LineTail = {InputCharacter}+

// White space.
SingleWhiteSpace = [ \t]
AnySpace = {LineTerminator} | {SingleWhiteSpace} | [\f]
OptionalWhiteSpace = {SingleWhiteSpace}*
RequiredWhiteSpace = {SingleWhiteSpace}+

// Request.
RequestMethod = GET|HEAD|POST|PUT|DELETE|CONNECT|PATCH|OPTIONS|TRACE
RequestPath = "/" [^#?\s]*
HttpVersion = HTTP\/{Digit}(\.{Digit})?
ResponseCode = [0-9]{3}

// Query
InterogationMark = "?"

// Header
HeaderName = [a-zA-Z0-9\-_]+
FieldName = [^\n\r:]+
FieldValue = {LineTail}

%include MultipartBoundaryMacros.jflex.inc

name = ({uchar}+{uchar_value}*)
separator = "="
pair_separator = "&"

space = "+"+
hex = [0-9A-Fa-f]
escape = "%" {hex} {hex}

uchar = ([a-zA-Z0-9\-_.*] | {escape})
uchar_value = ({uchar} | {space})

FallbackCharacter = .
NonPrintable = ([\x00-\x1F\x7F])+

Censored = "[redacted]"
Snipped = "[snip]"
ResponseDelim = ("┈┈┈┈┈┈┈┈┈┈┈┈┈⮝Request")?"┈┈┈┈┈┈┈┈┈┈┈┈┈⮟Response┈┈┈┈┈┈┈┈┈┈┈┈┈"
RequestPrefix = "┈┈┈┈┈┈┈┈┈┈┈┈┈⮟Request┈┈┈┈┈┈┈┈┈┈┈┈┈"

%state REQ_LINE
%state REQ_HEADER
%state REQ_BODY
%state QUERY_PARAM_NAME
%state QUERY_PARAM_VALUE
%state BODY_PARAM_NAME
%state BODY_PARAM_VALUE
%state BODY_MULTIPART_HEADER
%state ANY_BODY
%state PLAIN_TEXT_BODY

%%

//MARK: -jflex:states

{Censored} {addToken(Token.COMMENT_KEYWORD);}
{Snipped} {addToken(Token.COMMENT_KEYWORD);}
{ResponseDelim} {addToken(Token.PREPROCESSOR);addEndToken(HTTPTokenMaker.INTERNAL_REQUEST_AND_RESPONSE); return firstToken;}

<YYINITIAL> {
	{MultiplePartBoundary} {
		if (isMultiplePartBoundary()) {
			contentTypeManager.setContentType(zzCurrentPos, "text/plain");
			addToken(Token.COMMENT_DOCUMENTATION);
			addNullToken();
			return firstToken;
		} else {
			yypushback(yylength());
			yybegin(REQ_LINE);
		}
	}
	{RequestPrefix} {addToken(Token.PREPROCESSOR);}
	{Censored} {addToken(Token.COMMENT_KEYWORD);}
	{Snipped} {addToken(Token.COMMENT_KEYWORD);}
	{FallbackCharacter} {
		yypushback(yylength());
		yybegin(REQ_LINE);
	}
}

<REQ_LINE> {
	{Whitespace}  {addToken(Token.WHITESPACE);}
	{RequestMethod}{RequiredWhiteSpace} {handleInvalidToken(); contentTypeManager = new ContentTypeManager(); addToken(zzStartRead, zzMarkedPos-2, Token.RESERVED_WORD); addToken(zzMarkedPos-1, zzMarkedPos-1, Token.WHITESPACE); }
	{RequestPath} {handleInvalidToken(); addToken(Token.IDENTIFIER);}
	{InterogationMark} {handleInvalidToken();addToken(Token.SEPARATOR);yybegin(QUERY_PARAM_NAME);}
	{OptionalWhiteSpace}{HttpVersion} {handleInvalidToken(); addToken(Token.RESERVED_WORD_2);}
	{HttpVersion}{RequiredWhiteSpace}{ResponseCode}{LineTail} {handleInvalidToken(); setResponseMode();addToken(Token.RESERVED_WORD_2);}
	{FallbackCharacter} {yypushback(yylength());yybegin(REQ_HEADER);}
}

<REQ_HEADER> {
	{HeaderName}/: {handleInvalidToken(); addHeaderName();}
	:{OptionalWhiteSpace}{FieldValue} {handleInvalidToken(); addHeaderValue();}
	{FallbackCharacter} {yypushback(yylength()); yybegin(getBodyStateForMode());}
}

<QUERY_PARAM_NAME> {
	{name} { handleInvalidToken();addToken(Token.MARKUP_TAG_ATTRIBUTE); }
	{separator} {handleInvalidToken(); addToken(Token.SEPARATOR); yybegin(QUERY_PARAM_VALUE); }
	{Whitespace}  {handleInvalidToken();addToken(Token.WHITESPACE); yybegin(REQ_LINE);}
	[^=] { startInvalidToken(); }
}

<QUERY_PARAM_VALUE> {
	{uchar}+ { handleInvalidToken();addToken(Token.MARKUP_TAG_ATTRIBUTE_VALUE); }
	{space} { handleInvalidToken();addToken(Token.COMMENT_DOCUMENTATION); }
	{pair_separator} { handleInvalidToken();addToken(Token.SEPARATOR); yybegin(QUERY_PARAM_NAME); }
	{Whitespace}  {handleInvalidToken();addToken(Token.WHITESPACE); yybegin(REQ_LINE);}
	[^&] { startInvalidToken();}
}

<BODY_PARAM_NAME> {
	{name} { handleInvalidToken();addToken(Token.MARKUP_TAG_NAME); }
	{separator} {handleInvalidToken(); addToken(Token.SEPARATOR); yybegin(BODY_PARAM_VALUE); }
	[^=] { startInvalidToken(); }
}

<BODY_PARAM_VALUE> {
	{uchar}+ { handleInvalidToken();addToken(Token.MARKUP_TAG_ATTRIBUTE_VALUE); }
	{space} { handleInvalidToken();addToken(Token.COMMENT_DOCUMENTATION); }
	{pair_separator} { handleInvalidToken();addToken(Token.SEPARATOR); yybegin(BODY_PARAM_NAME); }
	[^&] { startInvalidToken();}
}

<REQ_BODY> {
	{FallbackCharacter} {
		yypushback(yylength());
		if (contentTypeManager.getContentType(zzStartRead).toLowerCase().startsWith("multipart/")) {
			yybegin(BODY_MULTIPART_HEADER);
		} else if (!contentTypeManager.getContentType(zzStartRead).toLowerCase().contains("x-www-form-urlencoded")) {
			yybegin(ANY_BODY); 
		} else {
			yybegin(BODY_PARAM_NAME);
		}
	}
}

<BODY_MULTIPART_HEADER> {
	{HeaderName}/:                           { addToken(Token.MARKUP_TAG_NAME); }
	:{OptionalWhiteSpace}{FieldValue}        { addHeaderValue(); }
	{LineTerminator}|{AnySpace}+             { addToken(Token.WHITESPACE); }
	{FallbackCharacter}                      { yypushback(yylength());yybegin(ANY_BODY); }
}


<ANY_BODY,PLAIN_TEXT_BODY> {
	{MultiplePartBoundary} {
		if (isMultiplePartBoundary()) {
			contentTypeManager.setContentType(zzCurrentPos, "text/plain");
			addToken(Token.COMMENT_DOCUMENTATION);
			addNullToken();
			return firstToken;
		} else {
			fallbackToTokenMaker();
		}
	}
	{Censored} {addToken(Token.COMMENT_KEYWORD);}
	{Snipped} {addToken(Token.COMMENT_KEYWORD);}
}

<ANY_BODY> {
	{FallbackCharacter} { fallbackToTokenMaker(); }
}

<PLAIN_TEXT_BODY> {
	// RSTA cannot handle excessively long tokens. This is a randomly chosen limit. 
	{LineTail} {
		int start = zzStartRead;
		int end   = zzMarkedPos;
        int len   = yylength();

        while (len > 1000) {
            addToken(start, start+999, Token.VARIABLE);
            start += 1000;
            len   -= 1000;
        }
        addToken(start, start+len-1, Token.VARIABLE);
	}
}


<YYINITIAL,REQ_LINE,REQ_HEADER,QUERY_PARAM_NAME,QUERY_PARAM_VALUE> {
	{LineTerminator} |
	<<EOF>> { handleInvalidToken(); addHeaderEndToken();return firstToken; }
}

<REQ_BODY,BODY_PARAM_NAME,BODY_PARAM_VALUE,BODY_MULTIPART_HEADER,ANY_BODY,PLAIN_TEXT_BODY> {
	{LineTerminator} |
	<<EOF>> { handleInvalidToken(); addBodyEndToken();return firstToken; }
}
