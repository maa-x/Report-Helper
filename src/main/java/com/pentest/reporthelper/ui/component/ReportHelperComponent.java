package com.pentest.reporthelper.ui.component;

import java.awt.BorderLayout;

import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;

import java.util.List;

import javax.swing.BoxLayout;

import javax.swing.JButton;

import javax.swing.JComponent;

import javax.swing.JPanel;
import javax.swing.JPopupMenu;

import javax.swing.JToolBar;

import org.fife.ui.rtextarea.RTextScrollPane;
import org.fife.ui.rtextarea.SearchContext;
import org.fife.ui.rtextarea.SearchEngine;

import com.pentest.reporthelper.formatter.ContentFormatter;
import com.pentest.reporthelper.formatter.strategies.HttpHeaderFormatterStrategy;
import com.pentest.reporthelper.ui.component.settings.AdvancedHeaderSettingsFrame;
import com.pentest.reporthelper.ui.component.settings.SettingsComponent;
import com.pentest.reporthelper.ui.component.settings.SettingsMenuPanel;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.core.ByteArray;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.logging.Logging;
import burp.api.montoya.persistence.Preferences;
import burp.api.montoya.ui.Selection;

public abstract class ReportHelperComponent extends JComponent {
    MontoyaApi api;
    Preferences preferences;
    HTTPMessageType messageType;

    protected Logging logging;
    protected JToolBar header;
    JPopupMenu settingsMenu;
    JButton settingsButton;

    JButton censorButton;
    JButton snipButton;

    SettingsMenuPanel settingsMenuPanel;

    protected JPanel syntaxPanel;
    protected RTextScrollPane scrollPane;
    protected ReportHelperTextArea textArea;
    protected HttpRequestResponse requestResponse;

    private AdvancedHeaderSettingsFrame advancedHeaderSettingsFrame = null;
    private EditorToolbar editorToolbar;

    protected Boolean includeRequest = false;
    protected Boolean includeResponse = false;
    protected Boolean separateLinesDelimeter = false;
    protected Boolean censorRequest = false;
    protected Boolean censorResponse = false;
    protected Boolean includeRequestHeaders = true;
    protected Boolean includeResponseHeaders = true;

    protected Boolean shouldFilterResponseHeaders = true;
    protected Boolean shouldFilterRequestHeaders = true;

    private List<String> requestHeadersToRemove = new ArrayList<>();
    private List<String> responseHeadersToRemove = new ArrayList<>();

    public Boolean getShouldFilterResponseHeaders() {
        return shouldFilterResponseHeaders;
    }

    public void setShouldFilterResponseHeaders(Boolean shouldFilterResponseHeaders) {
        this.shouldFilterResponseHeaders = shouldFilterResponseHeaders;
        refreshTextArea();
    }

    public Boolean getShouldFilterRequestHeaders() {
        return shouldFilterRequestHeaders;
    }

    public void setShouldFilterRequestHeaders(Boolean shouldFilterRequestHeaders) {
        this.shouldFilterRequestHeaders = shouldFilterRequestHeaders;
        refreshTextArea();
    }

    public MontoyaApi getApi() {
        return api;
    }

    public void setApi(MontoyaApi api) {
        this.api = api;
    }

    public Preferences getPreferences() {
        return preferences;
    }

    public HttpRequestResponse getRequestResponse() {
        return requestResponse;
    }

    public void setPreferences(Preferences preferences) {
        this.preferences = preferences;
    }

    public Logging getLogging() {
        return logging;
    }

    public void setLogging(Logging logging) {
        this.logging = logging;
    }

    public Boolean shouldIncludeRequest() {
        return includeRequest;
    }

    public Boolean shouldIncludeResponse() {
        return includeResponse;
    }

    public void setIncludeRequest(Boolean includeRequest) {
        this.includeRequest = includeRequest;
        refreshTextArea();
    }

    public void setIncludeResponse(Boolean includeResponse) {
        this.includeResponse = includeResponse;
        refreshTextArea();
    }

    public ReportHelperTextArea getTextArea() {
        return textArea;
    }

    public void setTextArea(ReportHelperTextArea textArea) {
        this.textArea = textArea;
        refreshTextArea();
    }

    public boolean shouldCensorRequest() {
        return censorRequest;
    }

    public void setCensorRequest(boolean censorRequest) {
        this.censorRequest = censorRequest;
        refreshTextArea();
    }

    public boolean shouldCensorResponse() {
        return censorResponse;
    }

    public void setCensorResponse(boolean censorResponse) {
        this.censorResponse = censorResponse;
        refreshTextArea();
    }

    public boolean shouldIncludeRequestHeaders() {
        return includeRequestHeaders;
    }

    public void setIncludeRequestHeaders(boolean includeRequestHeaders) {
        this.includeRequestHeaders = includeRequestHeaders;
        refreshTextArea();
    }

    public boolean shouldIncludeResponseHeaders() {
        return includeResponseHeaders;
    }

    public void setIncludeResponseHeaders(boolean includeResponseHeaders) {
        this.includeResponseHeaders = includeResponseHeaders;
        refreshTextArea();
    }

    public boolean isSeparateLinesDelimeter() {
        return separateLinesDelimeter;
    }

    public void setSeparateLinesDelimeter(boolean separateLinesDelimeter) {
        this.separateLinesDelimeter = separateLinesDelimeter;
        refreshTextArea();
    }

    public void headerSettingsChanged(List<String> requestHeadersToRemove, List<String> responseHeadersToRemove) {
        this.requestHeadersToRemove = requestHeadersToRemove;
        this.responseHeadersToRemove = responseHeadersToRemove;
        refreshTextArea();
    }

    protected void setupUIComponents() {
        setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));
        setupHeader();
        setupSyntaxPanel();
        setupSearchToolbar();
    }

    private void setupHeader() {
        header = new JToolBar();

        editorToolbar = new EditorToolbar(this);
        header.add(editorToolbar, BorderLayout.WEST);
        editorToolbar.configureToolbar();
        add(header);
        header.setVisible(true);
    }

    private void setupSearchToolbar() {
        SearchToolbarPanel searchToolbar = new SearchToolbarPanel(this);
        add(searchToolbar, BorderLayout.SOUTH);
    }

    public void searchText(String query, boolean isRegex, boolean isCaseSensitive, boolean forward, boolean highlight) {
        SearchContext context = new SearchContext();
        context.setSearchFor(query);
        context.setMatchCase(isCaseSensitive);
        context.setRegularExpression(isRegex);
        context.setSearchForward(forward);
        context.setWholeWord(false);
        context.setMarkAll(highlight);

        SearchEngine.find(textArea, context);
    }

    public void showAdvancedHeaderSettings() {
        if (advancedHeaderSettingsFrame == null) {
            advancedHeaderSettingsFrame = new AdvancedHeaderSettingsFrame(this);
        }
        advancedHeaderSettingsFrame.display();
    }

    private void setupSyntaxPanel() {
        String themeName = getThemeFromPreferences();

        syntaxPanel = new JPanel(new BorderLayout());
        textArea = new ReportHelperTextArea(logging, themeName);
        scrollPane = new RTextScrollPane(textArea);
        syntaxPanel.add(scrollPane);
        add(syntaxPanel);

        textArea.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                textArea.setTheme(getThemeFromPreferences());
            }
        });
    }

    private String getThemeFromPreferences() {
        String themeName = preferences.getString(SettingsComponent.THEME_KEY_STRING);
        themeName = themeName == null ? "/com/pentest/reporthelper/ui/themes/git.xml" : themeName;
        return themeName;
    }

    private HttpHeaderFormatterStrategy getRequestHeaderFormatterStrategy() {
        List<String> headersToRemove = shouldFilterRequestHeaders ? requestHeadersToRemove : new ArrayList<>();
        return StrategyFactory.getStrategy(includeRequestHeaders, censorRequest, headersToRemove);
    }

    private HttpHeaderFormatterStrategy getResponseHeaderFormatterStrategy() {
        List<String> headersToRemove = shouldFilterResponseHeaders ? responseHeadersToRemove : new ArrayList<>();
        return StrategyFactory.getStrategy(includeResponseHeaders, censorResponse, headersToRemove);
    }

    protected void refreshTextArea() {
        if (requestResponse == null || textArea == null) {
            return;
        }

        Boolean useSeparateLineDelimeter = preferences.getBoolean(SettingsComponent.SEPARATE_LINES_KEY_STRING);
        useSeparateLineDelimeter = useSeparateLineDelimeter == null ? true : useSeparateLineDelimeter;
        HttpHeaderFormatterStrategy requestStrategy = getRequestHeaderFormatterStrategy();
        HttpHeaderFormatterStrategy responseStrategy = getResponseHeaderFormatterStrategy();

        ContentFormatter contentFormatter = new ContentFormatter(requestStrategy, responseStrategy,
                this.requestResponse);
        String formattedContent = contentFormatter.getFormattedContent(includeRequest, includeResponse,
                useSeparateLineDelimeter);

        if (formattedContent.length() > 10000) {
            textArea.setLineWrap(false);
        }

        try {
            textArea.setText(formattedContent);
            textArea.setCaretPosition(0);
            textArea.discardAllEdits();
            textArea.setHyperlinksEnabled(false);
            textArea.setBracketMatchingEnabled(false);
        } catch (Exception e) {
            // If the text area throws an exception while parsing,
            // replace the text with the stacktrace.
            // This prevents the entire program from crashing.
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            textArea.setText("Error occurred: " + sw.toString());
            logging.logToError(sw.toString());
        }
    }

    public void copyToClipboard() {
        Boolean haveSelectedText = textArea.getSelectionStart() != textArea.getSelectionEnd();
        if (!haveSelectedText) {
            textArea.selectAll();
        }
        textArea.copy();
        if (!haveSelectedText) {
            textArea.select(0, 0);
        }
    }

    ReportHelperComponent(Logging logging, MontoyaApi api, HTTPMessageType messageType) {
        this.logging = logging;
        this.api = api;
        this.preferences = api.persistence().preferences();
        this.messageType = messageType;
        if (messageType == HTTPMessageType.REQUEST) {
            this.includeRequest = true;
            this.includeRequestHeaders = true;
            this.includeResponse = true;
        } else if (messageType == HTTPMessageType.RESPONSE) {
            this.includeResponse = true;
        }
        setupUIComponents();
    }

    public void setRequestResponse(HttpRequestResponse requestResponse) {
        this.requestResponse = requestResponse;
        if (advancedHeaderSettingsFrame == null) {
            advancedHeaderSettingsFrame = new AdvancedHeaderSettingsFrame(this);
        }
        if (advancedHeaderSettingsFrame != null) {
            advancedHeaderSettingsFrame.restoreHeaders();
        }
        requestHeadersToRemove = advancedHeaderSettingsFrame.getPersistedRequestHeadersToRemove();
        responseHeadersToRemove = advancedHeaderSettingsFrame.getPersistedResponseHeadersToRemove();
        refreshTextArea();
    }

    public Selection selectedData() {
        if (textArea.getSelectionStart() >= 0) {
            return Selection.selection(ByteArray.byteArray(textArea.getSelectedText()), textArea.getSelectionStart(),
                    textArea.getSelectionEnd());
        }
        return null;
    }

    protected enum HTTPMessageType {
        REQUEST,
        RESPONSE
    }

    public HTTPMessageType getMessageType() {
        return messageType;
    }
}
