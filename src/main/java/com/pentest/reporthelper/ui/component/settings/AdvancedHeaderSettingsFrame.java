package com.pentest.reporthelper.ui.component.settings;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;

import com.pentest.reporthelper.ui.component.ReportHelperComponent;

import burp.api.montoya.http.message.HttpHeader;

import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JCheckBox;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.Arrays;

public class AdvancedHeaderSettingsFrame extends JFrame {
    private ReportHelperComponent parent;
    private List<JCheckBox> requestHeadersList = new ArrayList<>();
    private List<JCheckBox> responseHeadersList = new ArrayList<>();
    private static final String CENSOR_REQUEST_HEADERS_KEY = "com.pentest.reporthelper.persistence.request.headers";
    private static final String CENSOR_RESPONSE_HEADERS_KEY = "com.pentest.reporthelper.persistence.response.headers";

    public AdvancedHeaderSettingsFrame(ReportHelperComponent parent) {
        this.parent = parent;
        restoreHeaders();
        parent.headerSettingsChanged(getRequestHeadersToRemove(), getResponseHeadersToRemove());
    }

    public void display() {
        JFrame frame = new JFrame("Burp Reporting Plugin - Advanced Header Settings");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(400, 300);
        frame.setLayout(new BorderLayout());
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                parent.headerSettingsChanged(getRequestHeadersToRemove(), getResponseHeadersToRemove());
            }
        });

        DefaultListModel<JCheckBox> requestListModel = new DefaultListModel<>();
        JList<JCheckBox> requestHeadersJList = new JList<>(requestListModel);
        requestHeadersJList.setCellRenderer(new CheckboxListCellRenderer());
        requestHeadersJList.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int index = requestHeadersJList.locationToIndex(e.getPoint());
                if (index != -1) {
                    JCheckBox checkBox = requestListModel.getElementAt(index);
                    checkBox.setSelected(!checkBox.isSelected());
                    requestHeadersJList.repaint();
                    persistHeaders();
                }
            }
        });

        DefaultListModel<JCheckBox> responseListModel = new DefaultListModel<>();
        JList<JCheckBox> responseHeadersJList = new JList<>(responseListModel);
        responseHeadersJList.setCellRenderer(new CheckboxListCellRenderer());
        responseHeadersJList.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int index = responseHeadersJList.locationToIndex(e.getPoint());
                if (index != -1) {
                    JCheckBox checkBox = responseListModel.getElementAt(index);
                    checkBox.setSelected(!checkBox.isSelected());
                    responseHeadersJList.repaint();
                    persistHeaders();
                }
            }
        });

        JScrollPane requestScrollPane = new JScrollPane(requestHeadersJList);
        JScrollPane responseScrollPane = new JScrollPane(responseHeadersJList);

        JPanel headersPanel = new JPanel(new GridLayout(1, 2));
        headersPanel.add(requestScrollPane);
        headersPanel.add(responseScrollPane);

        frame.add(headersPanel, BorderLayout.CENTER);
        frame.setVisible(true);

        restoreHeaders();

        for (JCheckBox checkBox : requestHeadersList) {
            requestListModel.addElement(checkBox);
        }
        for (JCheckBox checkBox : responseHeadersList) {
            responseListModel.addElement(checkBox);
        }
    }

    private class CheckboxListCellRenderer extends JCheckBox implements ListCellRenderer<JCheckBox> {
        @Override
        public Component getListCellRendererComponent(JList<? extends JCheckBox> list, JCheckBox value, int index,
                boolean isSelected, boolean cellHasFocus) {
            setEnabled(list.isEnabled());
            setSelected(value.isSelected());
            setFont(list.getFont());
            setBackground(list.getBackground());
            setForeground(list.getForeground());
            setText(value.getText());
            return this;
        }
    }

    private void persistHeaders() {
        String requestCsv = requestHeadersList.stream()
                .filter(JCheckBox::isSelected)
                .map(JCheckBox::getText)
                .collect(Collectors.joining(","));
        String responseCsv = responseHeadersList.stream()
                .filter(JCheckBox::isSelected)
                .map(JCheckBox::getText)
                .collect(Collectors.joining(","));
        parent.getPreferences().setString(CENSOR_REQUEST_HEADERS_KEY, requestCsv);
        parent.getPreferences().setString(CENSOR_RESPONSE_HEADERS_KEY, responseCsv);
    }

    private List<String> convertHeadersToStringList(List<HttpHeader> headers) {
        return headers.stream()
                .map(HttpHeader::name)
                .collect(Collectors.toList());
    }

    private List<String> filterHeaders(List<String> headers) {
        return headers.stream()
                .filter(header -> !header.equalsIgnoreCase("Content-Type") && // Content-Type is always included as
                                                                              // needed for parsing
                        !header.startsWith(":"))
                .collect(Collectors.toList());
    }

    private List<String> removeDuplicatesAndSort(List<String> headers) {
        return headers.stream()
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }

    public void restoreHeaders() {
        // reset current lists
        requestHeadersList.clear();
        responseHeadersList.clear();

        String persistedRequestCsv = parent.getPreferences().getString(CENSOR_REQUEST_HEADERS_KEY);
        String persistedResponseCsv = parent.getPreferences().getString(CENSOR_RESPONSE_HEADERS_KEY);
        Set<String> persistedRequestSet = new HashSet<>();
        Set<String> persistedResponseSet = new HashSet<>();

        if (persistedRequestCsv != null && !persistedRequestCsv.isEmpty()) {
            for (String header : persistedRequestCsv.split(",")) {
                persistedRequestSet.add(header.trim());
            }
        }
        if (persistedResponseCsv != null && !persistedResponseCsv.isEmpty()) {
            for (String header : persistedResponseCsv.split(",")) {
                persistedResponseSet.add(header.trim());
            }
        }

        if (parent.getRequestResponse() == null) {
            return;
        }

        List<String> allRequestHeaders = convertHeadersToStringList(parent.getRequestResponse().request().headers());
        List<String> allResponseHeaders = convertHeadersToStringList(parent.getRequestResponse().response().headers());

        List<String> filteredRequestHeaders = filterHeaders(allRequestHeaders);
        List<String> filteredResponseHeaders = filterHeaders(allResponseHeaders);

        List<String> uniqueSortedRequestHeaders = removeDuplicatesAndSort(filteredRequestHeaders);
        List<String> uniqueSortedResponseHeaders = removeDuplicatesAndSort(filteredResponseHeaders);

        for (String header : uniqueSortedRequestHeaders) {
            boolean shouldFilter = persistedRequestSet.contains(header);
            JCheckBox checkBox = new JCheckBox(header, shouldFilter);
            requestHeadersList.add(checkBox);
        }

        for (String header : uniqueSortedResponseHeaders) {
            boolean shouldFilter = persistedResponseSet.contains(header);
            JCheckBox checkBox = new JCheckBox(header, shouldFilter);
            responseHeadersList.add(checkBox);
        }
    }

    private List<String> getRequestHeadersToRemove() {
        List<String> headersToRemove = new ArrayList<>();
        for (JCheckBox checkBox : requestHeadersList) {
            if (checkBox.isSelected()) {
                headersToRemove.add(checkBox.getText());
            }
        }
        return headersToRemove;
    }

    private List<String> getResponseHeadersToRemove() {
        List<String> headersToRemove = new ArrayList<>();
        for (JCheckBox checkBox : responseHeadersList) {
            if (checkBox.isSelected()) {
                headersToRemove.add(checkBox.getText());
            }
        }
        return headersToRemove;
    }

    /**
     * Returns a List of request header names that should be removed according to the persisted preferences.
     */
    public List<String> getPersistedRequestHeadersToRemove() {
        String requestCsv = parent.getPreferences().getString(CENSOR_REQUEST_HEADERS_KEY);
        if (requestCsv == null || requestCsv.isEmpty()) {
            return new ArrayList<>();
        }
        return Arrays.stream(requestCsv.split(","))
                .map(String::trim)
                .collect(Collectors.toList());
    }

    /**
     * Returns a List of response header names that should be removed according to the persisted preferences.
     */
    public List<String> getPersistedResponseHeadersToRemove() {
        String responseCsv = parent.getPreferences().getString(CENSOR_RESPONSE_HEADERS_KEY);
        if (responseCsv == null || responseCsv.isEmpty()) {
            return new ArrayList<>();
        }
        return Arrays.stream(responseCsv.split(","))
                .map(String::trim)
                .collect(Collectors.toList());
    }
}