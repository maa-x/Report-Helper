package com.pentest.reporthelper.formatter;

import burp.api.montoya.http.message.HttpRequestResponse;
import com.pentest.reporthelper.formatter.strategies.HttpHeaderFormatterStrategy;
import com.pentest.reporthelper.formatter.strategies.NoOpFormatterStrategy;

/**
 * Responsible for formatting the content of HTTP requests and responses.
 */
public class ContentFormatter {
    
    /** The strategy used to format request headers. */
    private HttpHeaderFormatterStrategy requestStrategy;

    /** The strategy used to format response headers. */
    private HttpHeaderFormatterStrategy responseStrategy;
    
    /** The HTTP request and response pair to be formatted. */
    private final HttpRequestResponse requestResponse;

    /**
     * Constructs a new ContentFormatter with the given formatting strategy and HTTP request-response pair.
     * 
     * @param strategy The strategy used to format headers.
     * @param requestResponse The HTTP request and response pair to be formatted.
     */
    public ContentFormatter(HttpHeaderFormatterStrategy requestStrategy, HttpHeaderFormatterStrategy responseStrategy, HttpRequestResponse requestResponse) {
        if (requestStrategy != null) {
            this.requestStrategy = requestStrategy;
        } else {
            this.requestStrategy = new NoOpFormatterStrategy();
        }
        if (responseStrategy != null) {
            this.responseStrategy = responseStrategy;
        } else {
            this.responseStrategy = new NoOpFormatterStrategy();
        }
        this.requestResponse = requestResponse;
    }

    /**
     * Constructs a new ContentFormatter with no formatting strategy and HTTP request-response pair.
     * 
     * @param requestResponse The HTTP request and response pair to be formatted.
     */
    public ContentFormatter(HttpRequestResponse requestResponse) {
        // Set the default strategy if none is provided
        this.requestStrategy = new NoOpFormatterStrategy();
        this.responseStrategy = new NoOpFormatterStrategy();
        this.requestResponse = requestResponse;
    }

    
    /** 
     * @param requestStrategy
     */
    public void setRequestStrategy(HttpHeaderFormatterStrategy requestStrategy) {
        this.requestStrategy = (requestStrategy != null) ? requestStrategy : new NoOpFormatterStrategy();
    }

    /** 
     * @param responseStrategy
     */
    public void setResponseStrategy(HttpHeaderFormatterStrategy responseStrategy) {
        this.responseStrategy = (responseStrategy != null) ? responseStrategy : new NoOpFormatterStrategy();
    }

    /**
     * Produces a formatted string of the HTTP request and/or response based on the input flags.
     * 
     * @param includeRequest Flag to determine if the request should be included in the formatted content.
     * @param includeResponse Flag to determine if the response should be included in the formatted content.
     * @param delimitMessagesWithSeparateLines Flag to determine if the request and response should be separated by a line each or a single shared line.
     * @return A string representation of the formatted content.
     */
    public String getFormattedContent(boolean includeRequest, boolean includeResponse, Boolean delimitMessagesWithSeparateLines) {
        StringBuilder contents = new StringBuilder();
        
        if (includeRequest) {
            if (delimitMessagesWithSeparateLines) {
                contents.append("┈┈┈┈┈┈┈┈┈┈┈┈┈⮟Request┈┈┈┈┈┈┈┈┈┈┈┈┈\n");
            }
            contents.append(requestStrategy.formatRequest(requestResponse.request()).toString().trim());
        }
        if (includeRequest && includeResponse) {
            contents.append("\n");
            if (delimitMessagesWithSeparateLines) {
                contents.append("┈┈┈┈┈┈┈┈┈┈┈┈┈⮟Response┈┈┈┈┈┈┈┈┈┈┈┈┈\n");
            } else {
                contents.append("┈┈┈┈┈┈┈┈┈┈┈┈┈⮝Request┈┈┈┈┈┈┈┈┈┈┈┈┈⮟Response┈┈┈┈┈┈┈┈┈┈┈┈┈\n");
            }
        }
        if (includeResponse) {
            contents.append(responseStrategy.formatResponse(requestResponse.response()).toString().trim());
        }
        
        /* 
         * Remove CR to ensure word wrapping works correctly in the UI. Unsure if still needed.
         */
        return contents.toString().replaceAll("\r", "");
    }
}
